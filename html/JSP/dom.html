<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>


    <h1>클릭횟수: 0</h1>
    <button id="connect">이벤트 연결</button>
    <button id="disconnect">이벤트 제거</button>

    <!-- <div class="box">
        <span class="inner"> 테스트 입니다.</span> 
        <span class="inner2"> 테스트 입니다.</span> 
    </div>
    <script>
        const header = document.createElement('h1')
        //Document.createElement() 메서드는 지정한 tagName의 HTML 요소를 만들어 반환합니다.
    
        const inner = document.querySelector('.inner')
        //제공한 선택자 또는 선택자 뭉치와 일치하는 문서 내 첫 번째 Element를 반환합니다. 일치하는 요소가 없으면 null을 반환합니다.
        inner.parentNode.appendChild(header)  
        //한 노드를 특정 부모 노드의 자식 노드 리스트 중 마지막 자식으로 붙입니다. 만약 주어진 노드가 이미 문서에 존재하는 노드를 참조하고 있다면 appendChild() 메소드는 노드를 현재 위치에서 새로운 위치로 이동시킵니다. (문서에 존재하는 노드를 다른 곳으로 붙이기 전에 부모 노드로 부터 지워버릴 필요는 없습니다.)

        console.log(inner.nextSibling)
</script> -->

<!-- <style>
    user-secect: none; 문구 여러번 클릭 시 글자가 선택 되는 걸 방지
</style> -->
<script>
let counter = 0
let isConnect = false  // 현재 이벤트 연결 상태
const h1 = document.querySelector('h1')
const p = document.querySelector('p')
const conButten = document.querySelector('#connect')
const disconButten = document.querySelector('#disconnect')

const listener = function(){    // 이벤트 실행
    counter++;
    h1.textContent = `클릭 횟수: ${counter}`
}
h1.addEventListener('click', listener)

conButten.addEventListener('click', function(){
if(isConnect === true){
    p.textContent(`현재 연결 상태: ${isConnect}`)
    h1.addEventListener('click', listener)
}else{
    isConnect = true
    h1.addEventListener('click', listener)
    p.textContent(`연결 끓긴 상태 확인, 연결 중..`+ `<br>`)
    p.textContent(`연결 완료`+`<br>`)
    p.textContent(`현재 연결 상태: ${isConnect}`)
}
})

disconButten.removeEventListener('click', function(){
    if(isConnect === true){
        isConnect = false
        p.textContent(`연결 제거 완료: ${isConnect}` + `<br>`)
}else{
        p.textContent(`이미 연결이 종료 된 상태입니다. `+`<br>`)
        p.textContent(`현재 연결 상태: ${isConnect}`)
}
})

// const button = document.querySelector('button')

// button.addEventListener('click', function(){
//     alert('클릭')
// })

// document.body.onclick = function(){
//     alert('클릭')
// }

// function isClick(){
//     alert('클릭')
// }



</script>
    <!-- <button onclick="isClick">click me</button> -->


<!-- 
    click – 마우스버튼을 클릭하고 버튼에서 손가락을 떼면 발생한다.
mouseover – 마우스를 HTML요소 위에 올리면 발생한다.
mouseout – 마우스가 HTML요소 밖으로 벗어날 때 발생한다.
mousedown – 클릭을 하기 위해 마우스버튼을 누르고 아직 떼기 전인 그 순간, HTML요소를 드래그할 때 사용할 수 있다.
mouseup – 마우스버튼을 떼는 그 순간, 드래그한 HTML요소를 어딘가에 놓을 때 사용할 수 있다.
mousemove – 마우스가 움직일때마다 발생한다. 마우스커서의 현재 위치를 계속 기록하는 것에 사용할 수 있다.
focus – HTML요소에 포커스가 갔을때 발생한다.
blur – HTML요소가 포커스에서 벗어났을때 발생한다.
keypress – 키를 누르는 순간에 발생하고 키를 누르고 있는 동안 계속해서 발생한다.
keydown – 키를 누를 때 발생한다.
keyup – 키를 눌렀다가 떼는 순간에 발생한다.
load – 웹페이지에서 사용할 모든 파일의 다운로드가 완료되었을때 발생한다.
resize – 브라우저 창의 크기를 조절할때 발생한다.
scroll – 스크롤바를 드래그하거나 키보드(up, down)를 사용하거나 마우스 휠을 사용해서 웹페이지를 스크롤할 때 발생한다. 페이지에 스크롤바가 없다면 이벤트는 발생하지 않다.
unload – 링크를 클릭해서 다른 페이지로 이동하거나 브라우저 탭을 닫을 때 혹은 브라우저 창을 닫을 때 이벤트가 발생한다.
change – 폼 필드의 상태가 변경되었을 때 발생한다. 라디오 버튼을 클릭하거나 셀렉트 박스에서 값을 선택하는 경우를 예로 들수 있다. -->
</body>
</html>